# -*- coding: utf-8 -*-
"""ProcessHandwriting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sT1uLy-H04V43mwj5Ye5T9fKbsIRccwR
"""

!pip install pdf2image

!apt-get install poppler-utils

import glob
import imageio.v3 as iio
import matplotlib.pyplot as plt
import numpy as np
import skimage as ski
import pdf2image
import os
import filecmp
from PIL import Image

class HandwritingCompresser:

  def __init__(self, file_path):
    if HandwritingCompresser.get_filetype(file_path) == 'pdf':
      self.original = HandwritingCompresser.pdf_to_image(file_path)
    else:
      self.original = file_path
    self.processed = None

  def compress(self, threshold = 0.95):
    raw_image = iio.imread(uri=self.original)
    denoised_image = HandwritingCompresser.process_image(raw_image, threshold)
    #HandwritingCompresser.show_image(denoised_image)
    new_file = Image.fromarray(denoised_image.astype(np.uint8) * 255)
    self.processed = HandwritingCompresser.replace_file_extension(self.original, '_processed.png')
    new_file.save(self.processed)
    return new_file

  @staticmethod
  def process_image(raw_image, threshold):
    gray_image = ski.color.rgb2gray(raw_image)
    denoised_image = ski.filters.gaussian(gray_image, sigma=1.0)
    return denoised_image > threshold

  @staticmethod
  def get_filetype(file_path):
    return os.path.split(file_path)[1].split('.')[1]

  @staticmethod
  def pdf_to_image(pdf_path):
    image = pdf2image.convert_from_path(pdf_path)
    file_path = HandwritingCompresser.replace_file_extension(pdf_path, '.jpg')
    for count, page in enumerate(image):
      image[count].save(file_path, 'JPEG')
    return file_path

  @staticmethod
  def show_graylevel_histogram(image):
    histogram, bin_edges = np.histogram(image, bins=256, range=(0.0, 1.0))

    fig, ax = plt.subplots()
    ax.plot(bin_edges[0:-1], histogram)
    ax.set_title("Grayscale Histogram")
    ax.set_xlabel("gray value")
    ax.set_ylabel("pixel count")
    ax.set_xlim(0, 1.0)

  @staticmethod
  def show_image(image):
    fig, ax = plt.subplots()
    ax.imshow(image, cmap = 'gray')

  @staticmethod
  def replace_file_extension(file_path, new_extension):
    return os.path.splitext(file_path)[0] + new_extension

  ######### Tests #########

  @staticmethod
  def pdf_to_image_test():
    assert filecmp.cmp(HandwritingCompresser.pdf_to_image('/content/handwriting_test.pdf'), '/content/img.jpg', shallow=False)

  @staticmethod
  def get_filetype_test():
    assert HandwritingCompresser.get_filetype('/content/handwriting_test.jpg') == 'jpg'

  @staticmethod
  def replace_file_extension_test():
    file_path = '/content/handwriting_test.pdf'
    new_extension = '.jpg'
    assert HandwritingCompresser.replace_file_extension(file_path, new_extension) == '/content/handwriting_test.jpg'

  @staticmethod
  def run_tests():
    HandwritingCompresser.pdf_to_image_test()
    HandwritingCompresser.get_filetype_test()
    HandwritingCompresser.replace_file_extension_test()

processed_writing = HandwritingCompresser('/content/handwriting_test.pdf')
processed_writing.compress()

import cv2
import numpy as np
from skimage.morphology import skeletonize
from skimage import measure
from scipy.interpolate import splprep, splev
import matplotlib.pyplot as plt

# Load and binarize the image
img = cv2.imread("handwriting_test_processed.png", cv2.IMREAD_GRAYSCALE)
_, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)

# Skeletonize (convert to 0/1 binary first)
skeleton = skeletonize(binary // 255)

# Find all contours in the skeleton
contours = measure.find_contours(skeleton, 0.5)

all_points = []

for contour in contours:
    if len(contour) < 5:
        continue  # Skip very short or noisy contours

    y, x = contour[:, 0], contour[:, 1]

    try:
        # Smooth and resample each contour
        tck, _ = splprep([x, y], s=1)
        u_new = np.linspace(0, 1, num=max(10, len(x) // 3))  # Adjustable density
        x_new, y_new = splev(u_new, tck)

        for x_, y_ in zip(x_new, y_new):
            all_points.append((x_, y_))
    except:
        # If a contour can't be interpolated, just skip it
        continue

# Save bead coordinates to an OpenSCAD file
with open("beads.scad", "w") as f:
    f.write("bead_points = [\n")
    for x_, y_ in all_points:
        f.write(f"    [{x_:.2f}, {y_:.2f}],\n")
    f.write("];\n")

print(f"Exported {len(all_points)} bead points.")

plt.figure(figsize=(8, 8))
for x_, y_ in all_points:
    plt.plot(x_, y_, 'bo', markersize=1)
plt.gca().invert_yaxis()
plt.title("Preview of Bead Placement")
plt.show()